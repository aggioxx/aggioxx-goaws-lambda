<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile" />
              <option name="originalContent" value="# syntax=docker/dockerfile:1&#10;FROM golang:1.24 as builder&#10;WORKDIR /app&#10;COPY go.mod go.sum ./&#10;RUN go mod download&#10;COPY . .&#10;RUN CGO_ENABLED=0 GOOS=linux go build -o main main.go&#10;&#10;FROM public.ecr.aws/lambda/go:1&#10;COPY --from=builder /app/main /var/task/main&#10;CMD [&quot;main&quot;]&#10;" />
              <option name="updatedContent" value="# syntax=docker/dockerfile:1&#10;FROM golang:1.24 as builder&#10;WORKDIR /app&#10;COPY go.mod go.sum ./&#10;RUN go mod download&#10;COPY . .&#10;RUN CGO_ENABLED=0 GOOS=linux go build -o main main.go&#10;&#10;FROM public.ecr.aws/lambda/go:1&#10;COPY --from=builder /app/main /var/task/main&#10;CMD [&quot;main&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/application/event_service.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/application/event_service.go" />
              <option name="updatedContent" value="package application&#10;&#10;import (&#10;&#9;&quot;awesomeProject1/app/domain&quot;&#10;&#9;&quot;awesomeProject1/app/infrastructure&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;type EventService struct {&#10;&#9;SNSPublisher infrastructure.SNSPublisher&#10;}&#10;&#10;func (s *EventService) ProcessAndPublishEvent(payload map[string]interface{}) error {&#10;&#9;// Add processing logic (e.g., add timestamp)&#10;&#9;event := domain.Event{&#10;&#9;&#9;ID:          &quot;unique-id&quot;, // Replace with actual ID generation logic&#10;&#9;&#9;Payload:     payload,&#10;&#9;&#9;ProcessedAt: time.Now().Format(time.RFC3339),&#10;&#9;}&#10;&#10;&#9;// Publish to SNS&#10;&#9;return s.SNSPublisher.Publish(event)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/cmd/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/cmd/main.go" />
              <option name="originalContent" value="package main&#10;&#10;import (&#10;&#9;&quot;awesomeProject1/internal/adapter&quot;&#10;&#9;httpServer &quot;awesomeProject1/internal/adapter/http/server&quot;&#10;&#9;&quot;awesomeProject1/internal/core/domain/service&quot;&#10;&#9;&quot;awesomeProject1/pkg/logger&quot;&#10;&#9;&quot;context&quot;&#10;&#9;&quot;github.com/aws/aws-lambda-go/lambda&quot;&#10;&#9;&quot;github.com/aws/aws-sdk-go-v2/config&quot;&#10;&#9;&quot;github.com/aws/aws-sdk-go-v2/service/sns&quot;&#10;&#9;&quot;os&quot;&#10;)&#10;&#10;func main() {&#10;&#9;log := logger.New()&#10;&#9;log.Info(&quot;Initializing Lambda application&quot;)&#10;&#10;&#9;// Load AWS configuration&#10;&#9;cfg, err := config.LoadDefaultConfig(context.TODO())&#10;&#9;if err != nil {&#10;&#9;&#9;log.Errorf(&quot;Failed to load AWS configuration: %v&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Get SNS topic ARN from environment variable&#10;&#9;topicArn := os.Getenv(&quot;SNS_TOPIC_ARN&quot;)&#10;&#9;if topicArn == &quot;&quot; {&#10;&#9;&#9;topicArn = &quot;arn:aws:sns:us-east-1:000000000000:my-topic&quot; // fallback for local development&#10;&#9;&#9;log.Warn(&quot;SNS_TOPIC_ARN not set, using default value&quot;)&#10;&#9;}&#10;&#10;&#9;// Initialize SNS client and publisher (secondary adapter)&#10;&#9;snsClient := sns.NewFromConfig(cfg)&#10;&#9;snsPublisher := &amp;adapter.SNSPublisher{&#10;&#9;&#9;Client:   snsClient,&#10;&#9;&#9;TopicArn: topicArn,&#10;&#9;}&#10;&#10;&#9;// Initialize domain service with the publisher&#10;&#9;eventService := service.NewEventService(snsPublisher)&#10;&#10;&#9;// Initialize HTTP server with the event service&#10;&#9;server := httpServer.NewServer(eventService)&#10;&#10;&#9;log.Info(&quot;Lambda application initialized successfully&quot;)&#10;&#10;&#9;// Check if running locally or in Lambda&#10;&#9;if os.Getenv(&quot;AWS_LAMBDA_RUNTIME_API&quot;) != &quot;&quot; {&#10;&#9;&#9;// Running in Lambda environment&#10;&#9;&#9;log.Info(&quot;Starting Lambda handler&quot;)&#10;&#9;&#9;lambda.Start(server.Handler)&#10;&#9;} else {&#10;&#9;&#9;// Running locally for development&#10;&#9;&#9;log.Info(&quot;Running locally for development&quot;)&#10;&#9;&#9;server.Start()&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package main&#10;&#10;import (&#10;&#9;&quot;awesomeProject1/internal/adapter&quot;&#10;&#9;httpServer &quot;awesomeProject1/internal/adapter/http/server&quot;&#10;&#9;&quot;awesomeProject1/internal/core/domain/service&quot;&#10;&#9;&quot;awesomeProject1/pkg/cfg&quot;&#10;&#9;&quot;awesomeProject1/pkg/logger&quot;&#10;&#9;&quot;github.com/aws/aws-lambda-go/lambda&quot;&#10;&#9;&quot;os&quot;&#10;)&#10;&#10;func main() {&#10;&#9;log := logger.New()&#10;&#9;log.Info(&quot;Initializing Lambda application&quot;)&#10;&#10;&#9;// Load configuration&#10;&#9;config, err := cfg.Load()&#10;&#9;if err != nil {&#10;&#9;&#9;log.Errorf(&quot;Failed to load configuration: %v&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;log.Infof(&quot;Application: %s, Environment: %s&quot;, config.App.Name, config.App.Environment)&#10;&#10;&#9;// Initialize AWS services&#10;&#9;awsService, err := cfg.NewAWSService(config)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Errorf(&quot;Failed to initialize AWS services: %v&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Log which endpoint we're using&#10;&#9;if config.IsLocalStack() {&#10;&#9;&#9;log.Infof(&quot;Using LocalStack endpoint: %s&quot;, config.AWS.LocalStack.Endpoint)&#10;&#9;} else {&#10;&#9;&#9;log.Info(&quot;Using AWS SNS service&quot;)&#10;&#9;}&#10;&#10;&#9;// Initialize SNS publisher (secondary adapter)&#10;&#9;snsPublisher := &amp;adapter.SNSPublisher{&#10;&#9;&#9;Client:   awsService.GetSNSClient(),&#10;&#9;&#9;TopicArn: awsService.GetSNSTopicArn(),&#10;&#9;}&#10;&#10;&#9;log.Infof(&quot;SNS Topic ARN: %s&quot;, awsService.GetSNSTopicArn())&#10;&#10;&#9;// Initialize domain service with the publisher&#10;&#9;eventService := service.NewEventService(snsPublisher)&#10;&#10;&#9;// Initialize HTTP server with the event service&#10;&#9;server := httpServer.NewServer(eventService)&#10;&#10;&#9;log.Info(&quot;Lambda application initialized successfully&quot;)&#10;&#10;&#9;// Check if running locally or in Lambda&#10;&#9;if os.Getenv(&quot;AWS_LAMBDA_RUNTIME_API&quot;) != &quot;&quot; {&#10;&#9;&#9;// Running in Lambda environment&#10;&#9;&#9;log.Info(&quot;Starting Lambda handler&quot;)&#10;&#9;&#9;lambda.Start(server.Handler)&#10;&#9;} else {&#10;&#9;&#9;// Running locally for development&#10;&#9;&#9;log.Info(&quot;Running locally for development&quot;)&#10;&#9;&#9;log.Infof(&quot;Server will start on port: %d&quot;, config.Server.Port)&#10;&#9;&#9;server.Start()&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/domain/event.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/domain/event.go" />
              <option name="updatedContent" value="package domain&#10;&#10;type Event struct {&#10;&#9;ID          string                 `json:&quot;id&quot;`&#10;&#9;Payload     map[string]interface{} `json:&quot;payload&quot;`&#10;&#9;ProcessedAt string                 `json:&quot;processed_at&quot;`&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/env.yaml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/env.yaml" />
              <option name="updatedContent" value="# Application Configuration&#10;app:&#10;  name: &quot;eventos-operacao-service&quot;&#10;  environment: &quot;local&quot; # local, development, staging, production&#10;&#10;# AWS Configuration&#10;aws:&#10;  region: &quot;us-east-1&quot;&#10;  localstack:&#10;    enabled: true&#10;    endpoint: &quot;http://localhost:4566&quot;&#10;  &#10;# SNS Configuration&#10;sns:&#10;  topic_arn: &quot;arn:aws:sns:us-east-1:000000000000:eventos-operacao-topic&quot;&#10;  topic_arn_prod: &quot;arn:aws:sns:us-east-1:YOUR-ACCOUNT-ID:eventos-operacao-topic&quot;&#10;&#10;# Server Configuration&#10;server:&#10;  port: 8080&#10;  &#10;# Logging Configuration&#10;logging:&#10;  level: &quot;info&quot; # debug, info, warn, error" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/infrastructure/sns_publisher.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/infrastructure/sns_publisher.go" />
              <option name="updatedContent" value="package infrastructure&#10;&#10;import (&#10;&#9;&quot;awesomeProject1/app/domain&quot;&#10;&#9;&quot;context&quot;&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;github.com/aws/aws-sdk-go-v2/aws&quot;&#10;&#9;&quot;github.com/aws/aws-sdk-go-v2/service/sns&quot;&#10;)&#10;&#10;type SNSPublisher struct {&#10;&#9;Client   *sns.Client&#10;&#9;TopicArn string&#10;}&#10;&#10;func (p *SNSPublisher) Publish(event domain.Event) error {&#10;&#9;message, err := json.Marshal(event)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;_, err = p.Client.Publish(context.TODO(), &amp;sns.PublishInput{&#10;&#9;&#9;Message:  aws.String(string(message)),&#10;&#9;&#9;TopicArn: aws.String(p.TopicArn),&#10;&#9;})&#10;&#9;return err&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/internal/adapter/http/event_handler.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/internal/adapter/http/event_handler.go" />
              <option name="originalContent" value="package http&#10;&#10;import (&#10;&#9;&quot;awesomeProject1/internal/core/port&quot;&#10;&#9;&quot;awesomeProject1/pkg/logger&quot;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;)&#10;&#10;type EventHandler struct {&#10;&#9;EventService port.EventInboundPort&#10;}&#10;&#10;type EventosOperacaoPayload struct {&#10;&#9;IdPessoaFisica       string   `json:&quot;idPessoaFisica&quot;`&#10;&#9;IdPessoaJuridica     string   `json:&quot;idPessoaJuridica&quot;`&#10;&#9;NumeroContrato       string   `json:&quot;numeroContrato&quot;`&#10;&#9;IsMultiplosContratos bool     `json:&quot;isMultiplosContratos&quot;`&#10;&#9;IdTipoContrato       string   `json:&quot;idTipoContrato&quot;`&#10;&#9;Metadata             Metadata `json:&quot;metadata&quot;`&#10;}&#10;&#10;type Metadata struct {&#10;&#9;Id              string `json:&quot;id&quot;`&#10;&#9;Nome            string `json:&quot;nome&quot;`&#10;&#9;Descricao       string `json:&quot;descricao&quot;`&#10;&#9;DataCriacao     string `json:&quot;dataCriacao&quot;`&#10;&#9;DataAtualizacao string `json:&quot;dataAtualizacao&quot;`&#10;}&#10;&#10;func NewEventHandler(eventService port.EventInboundPort) *EventHandler {&#10;&#9;return &amp;EventHandler{&#10;&#9;&#9;EventService: eventService,&#10;&#9;}&#10;}&#10;&#10;func (h *EventHandler) HandleEventosOperacao(c *gin.Context) {&#10;&#9;log := logger.New()&#10;&#10;&#9;var payload EventosOperacaoPayload&#10;&#9;if err := c.ShouldBindJSON(&amp;payload); err != nil {&#10;&#9;&#9;log.Warnf(&quot;Invalid request body: %v&quot;, err)&#10;&#9;&#9;c.JSON(400, gin.H{&quot;error&quot;: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Validate required fields - at least one of the person identifiers must be present&#10;&#9;if payload.IdPessoaFisica == &quot;&quot; &amp;&amp; payload.IdPessoaJuridica == &quot;&quot; {&#10;&#9;&#9;log.Warn(&quot;Missing required fields: at least one of idPessoaFisica or idPessoaJuridica must be provided&quot;)&#10;&#9;&#9;c.JSON(400, gin.H{&quot;error&quot;: &quot;Missing required fields: at least one of idPessoaFisica or idPessoaJuridica must be provided&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Determine event type based on payload content&#10;&#9;eventType := h.determineEventType(payload)&#10;&#10;&#9;// Convert to map for processing&#10;&#9;payloadMap := map[string]interface{}{&#10;&#9;&#9;&quot;idPessoaFisica&quot;:       payload.IdPessoaFisica,&#10;&#9;&#9;&quot;idPessoaJuridica&quot;:     payload.IdPessoaJuridica,&#10;&#9;&#9;&quot;numeroContrato&quot;:       payload.NumeroContrato,&#10;&#9;&#9;&quot;isMultiplosContratos&quot;: payload.IsMultiplosContratos,&#10;&#9;&#9;&quot;idTipoContrato&quot;:       payload.IdTipoContrato,&#10;&#9;&#9;&quot;metadata&quot;:             payload.Metadata,&#10;&#9;}&#10;&#10;&#9;log.Infof(&quot;Processing eventos_operacao event of type: %s for metadata.id: %s&quot;, eventType, payload.Metadata.Id)&#10;&#9;if err := h.EventService.ProcessEvent(eventType, payloadMap); err != nil {&#10;&#9;&#9;log.Errorf(&quot;Failed to process event: %v&quot;, err)&#10;&#9;&#9;c.JSON(500, gin.H{&quot;error&quot;: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;log.Info(&quot;Event processed successfully&quot;)&#10;&#9;c.JSON(200, gin.H{&quot;message&quot;: &quot;Event processed successfully&quot;})&#10;}&#10;&#10;// Determine event type based on payload content&#10;func (h *EventHandler) determineEventType(payload EventosOperacaoPayload) string {&#10;&#9;// Business logic to determine event type based on payload content&#10;&#9;if payload.IdPessoaFisica != &quot;&quot; {&#10;&#9;&#9;return &quot;pessoa_fisica_event&quot;&#10;&#9;} else if payload.IdPessoaJuridica != &quot;&quot; {&#10;&#9;&#9;return &quot;pessoa_juridica_event&quot;&#10;&#9;} else if payload.NumeroContrato != &quot;&quot; {&#10;&#9;&#9;return &quot;contrato_event&quot;&#10;&#9;}&#10;&#9;return &quot;generic_operacao_event&quot;&#10;}&#10;" />
              <option name="updatedContent" value="package http&#10;&#10;import (&#10;&#9;&quot;awesomeProject1/internal/core/domain/model&quot;&#10;&#9;&quot;awesomeProject1/internal/core/port&quot;&#10;&#9;&quot;awesomeProject1/pkg/logger&quot;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;)&#10;&#10;type EventHandler struct {&#10;&#9;EventService port.EventInboundPort&#10;}&#10;&#10;type EventosOperacaoPayload struct {&#10;&#9;IdPessoaFisica       string           `json:&quot;idPessoaFisica&quot;`&#10;&#9;IdPessoaJuridica     string           `json:&quot;idPessoaJuridica&quot;`&#10;&#9;NumeroContrato       string           `json:&quot;numeroContrato&quot;`&#10;&#9;IsMultiplosContratos bool             `json:&quot;isMultiplosContratos&quot;`&#10;&#9;IdTipoContrato       string           `json:&quot;idTipoContrato&quot;`&#10;&#9;Metadata             model.Metadata   `json:&quot;metadata&quot;`&#10;}&#10;&#10;func NewEventHandler(eventService port.EventInboundPort) *EventHandler {&#10;&#9;return &amp;EventHandler{&#10;&#9;&#9;EventService: eventService,&#10;&#9;}&#10;}&#10;&#10;func (h *EventHandler) HandleEventosOperacao(c *gin.Context) {&#10;&#9;log := logger.New()&#10;&#10;&#9;var payload EventosOperacaoPayload&#10;&#9;if err := c.ShouldBindJSON(&amp;payload); err != nil {&#10;&#9;&#9;log.Warnf(&quot;Invalid request body: %v&quot;, err)&#10;&#9;&#9;c.JSON(400, gin.H{&quot;error&quot;: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Map payload to domain model&#10;&#9;eventosOperacao := &amp;model.EventosOperacao{&#10;&#9;&#9;IdPessoaFisica:       payload.IdPessoaFisica,&#10;&#9;&#9;IdPessoaJuridica:     payload.IdPessoaJuridica,&#10;&#9;&#9;NumeroContrato:       payload.NumeroContrato,&#10;&#9;&#9;IsMultiplosContratos: payload.IsMultiplosContratos,&#10;&#9;&#9;IdTipoContrato:       payload.IdTipoContrato,&#10;&#9;&#9;Metadata:             payload.Metadata,&#10;&#9;}&#10;&#10;&#9;// Validate using domain logic&#10;&#9;if !eventosOperacao.IsValid() {&#10;&#9;&#9;log.Warn(&quot;Missing required fields: at least one of idPessoaFisica or idPessoaJuridica must be provided&quot;)&#10;&#9;&#9;c.JSON(400, gin.H{&quot;error&quot;: &quot;Missing required fields: at least one of idPessoaFisica or idPessoaJuridica must be provided&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;log.Infof(&quot;Processing eventos_operacao for metadata.id: %s&quot;, eventosOperacao.Metadata.Id)&#10;&#9;if err := h.EventService.ProcessEventosOperacao(eventosOperacao); err != nil {&#10;&#9;&#9;log.Errorf(&quot;Failed to process event: %v&quot;, err)&#10;&#9;&#9;c.JSON(500, gin.H{&quot;error&quot;: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;log.Info(&quot;Event processed successfully&quot;)&#10;&#9;c.JSON(200, gin.H{&quot;message&quot;: &quot;Event processed successfully&quot;})&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/internal/adapter/http/server/server.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/internal/adapter/http/server/server.go" />
              <option name="originalContent" value="package server&#10;&#10;import (&#10;&#9;&quot;awesomeProject1/internal/adapter/http&quot;&#10;&#9;&quot;awesomeProject1/internal/core/port&quot;&#10;&#9;&quot;awesomeProject1/pkg/logger&quot;&#10;&#9;&quot;context&quot;&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/aws/aws-lambda-go/events&quot;&#10;&#9;ginEngine &quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;strings&quot;&#10;)&#10;&#10;type Server struct {&#10;&#9;EventHandler *http.EventHandler&#10;}&#10;&#10;func NewServer(eventService port.EventInboundPort) *Server {&#10;&#9;return &amp;Server{&#10;&#9;&#9;EventHandler: http.NewEventHandler(eventService),&#10;&#9;}&#10;}&#10;&#10;// Handler for Lambda - processes API Gateway events directly&#10;func (s *Server) Handler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {&#10;&#9;log := logger.New()&#10;&#9;log.Info(&quot;Processing Lambda request&quot;)&#10;&#10;&#9;headers := map[string]string{&#10;&#9;&#9;&quot;Content-Type&quot;:                 &quot;application/json&quot;,&#10;&#9;&#9;&quot;Access-Control-Allow-Origin&quot;:  &quot;*&quot;,&#10;&#9;&#9;&quot;Access-Control-Allow-Headers&quot;: &quot;Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token&quot;,&#10;&#9;&#9;&quot;Access-Control-Allow-Methods&quot;: &quot;POST,OPTIONS&quot;,&#10;&#9;}&#10;&#10;&#9;if req.HTTPMethod == &quot;OPTIONS&quot; {&#10;&#9;&#9;return events.APIGatewayProxyResponse{&#10;&#9;&#9;&#9;StatusCode: 200,&#10;&#9;&#9;&#9;Headers:    headers,&#10;&#9;&#9;&#9;Body:       &quot;&quot;,&#10;&#9;&#9;}, nil&#10;&#9;}&#10;&#10;&#9;if req.HTTPMethod != &quot;POST&quot; {&#10;&#9;&#9;log.Warnf(&quot;Method not allowed: %s&quot;, req.HTTPMethod)&#10;&#9;&#9;return events.APIGatewayProxyResponse{&#10;&#9;&#9;&#9;StatusCode: 405,&#10;&#9;&#9;&#9;Headers:    headers,&#10;&#9;&#9;&#9;Body:       `{&quot;error&quot;: &quot;Method not allowed&quot;}`,&#10;&#9;&#9;}, nil&#10;&#9;}&#10;&#10;&#9;if !strings.HasSuffix(req.Path, &quot;/eventos_operacao&quot;) {&#10;&#9;&#9;log.Warnf(&quot;Path not found: %s&quot;, req.Path)&#10;&#9;&#9;return events.APIGatewayProxyResponse{&#10;&#9;&#9;&#9;StatusCode: 404,&#10;&#9;&#9;&#9;Headers:    headers,&#10;&#9;&#9;&#9;Body:       `{&quot;error&quot;: &quot;Path not found&quot;}`,&#10;&#9;&#9;}, nil&#10;&#9;}&#10;&#10;&#9;// Parse the eventos_operacao payload&#10;&#9;var payload http.EventosOperacaoPayload&#10;&#9;if err := json.Unmarshal([]byte(req.Body), &amp;payload); err != nil {&#10;&#9;&#9;log.Warnf(&quot;Invalid JSON body: %v&quot;, err)&#10;&#9;&#9;return events.APIGatewayProxyResponse{&#10;&#9;&#9;&#9;StatusCode: 400,&#10;&#9;&#9;&#9;Headers:    headers,&#10;&#9;&#9;&#9;Body:       fmt.Sprintf(`{&quot;error&quot;: &quot;Invalid JSON: %s&quot;}`, err.Error()),&#10;&#9;&#9;}, nil&#10;&#9;}&#10;&#10;&#9;// Validate required fields - at least one of the person identifiers must be present&#10;&#9;if payload.IdPessoaFisica == &quot;&quot; &amp;&amp; payload.IdPessoaJuridica == &quot;&quot; {&#10;&#9;&#9;log.Warn(&quot;Missing required fields: at least one of idPessoaFisica or idPessoaJuridica must be provided&quot;)&#10;&#9;&#9;return events.APIGatewayProxyResponse{&#10;&#9;&#9;&#9;StatusCode: 400,&#10;&#9;&#9;&#9;Headers:    headers,&#10;&#9;&#9;&#9;Body:       `{&quot;error&quot;: &quot;Missing required fields: at least one of idPessoaFisica or idPessoaJuridica must be provided&quot;}`,&#10;&#9;&#9;}, nil&#10;&#9;}&#10;&#10;&#9;// Determine event type based on payload content&#10;&#9;eventType := s.determineEventType(payload)&#10;&#10;&#9;// Convert to map for processing&#10;&#9;payloadMap := map[string]interface{}{&#10;&#9;&#9;&quot;idPessoaFisica&quot;:       payload.IdPessoaFisica,&#10;&#9;&#9;&quot;idPessoaJuridica&quot;:     payload.IdPessoaJuridica,&#10;&#9;&#9;&quot;numeroContrato&quot;:       payload.NumeroContrato,&#10;&#9;&#9;&quot;isMultiplosContratos&quot;: payload.IsMultiplosContratos,&#10;&#9;&#9;&quot;idTipoContrato&quot;:       payload.IdTipoContrato,&#10;&#9;&#9;&quot;metadata&quot;:             payload.Metadata,&#10;&#9;}&#10;&#10;&#9;log.Infof(&quot;Processing eventos_operacao event of type: %s for metadata.id: %s&quot;, eventType, payload.Metadata.Id)&#10;&#9;if err := s.EventHandler.EventService.ProcessEvent(eventType, payloadMap); err != nil {&#10;&#9;&#9;log.Errorf(&quot;Failed to process event: %v&quot;, err)&#10;&#9;&#9;return events.APIGatewayProxyResponse{&#10;&#9;&#9;&#9;StatusCode: 500,&#10;&#9;&#9;&#9;Headers:    headers,&#10;&#9;&#9;&#9;Body:       fmt.Sprintf(`{&quot;error&quot;: &quot;%s&quot;}`, err.Error()),&#10;&#9;&#9;}, nil&#10;&#9;}&#10;&#10;&#9;log.Info(&quot;Event processed successfully&quot;)&#10;&#9;return events.APIGatewayProxyResponse{&#10;&#9;&#9;StatusCode: 200,&#10;&#9;&#9;Headers:    headers,&#10;&#9;&#9;Body:       `{&quot;message&quot;: &quot;Event processed successfully&quot;}`,&#10;&#9;}, nil&#10;}&#10;&#10;func (s *Server) Start() {&#10;&#9;log := logger.New()&#10;&#9;log.Info(&quot;Starting GIN server for local development&quot;)&#10;&#10;&#9;r := ginEngine.Default()&#10;&#9;r.POST(&quot;/callbacks-trackingagrovarejo/v1/eventos_operacao&quot;, s.EventHandler.HandleEventosOperacao)&#10;&#10;&#9;if err := r.Run(&quot;:8080&quot;); err != nil {&#10;&#9;&#9;log.Errorf(&quot;Failed to start server: %v&quot;, err)&#10;&#9;}&#10;}&#10;&#10;// Determine event type based on payload content&#10;func (s *Server) determineEventType(payload http.EventosOperacaoPayload) string {&#10;&#9;// Business logic to determine event type based on payload content&#10;&#9;if payload.IdPessoaFisica != &quot;&quot; {&#10;&#9;&#9;return &quot;pessoa_fisica_event&quot;&#10;&#9;} else if payload.IdPessoaJuridica != &quot;&quot; {&#10;&#9;&#9;return &quot;pessoa_juridica_event&quot;&#10;&#9;} else if payload.NumeroContrato != &quot;&quot; {&#10;&#9;&#9;return &quot;contrato_event&quot;&#10;&#9;}&#10;&#9;return &quot;generic_operacao_event&quot;&#10;}&#10;" />
              <option name="updatedContent" value="package server&#10;&#10;import (&#10;&#9;&quot;awesomeProject1/internal/adapter/http&quot;&#10;&#9;&quot;awesomeProject1/internal/core/domain/model&quot;&#10;&#9;&quot;awesomeProject1/internal/core/port&quot;&#10;&#9;&quot;awesomeProject1/pkg/logger&quot;&#10;&#9;&quot;context&quot;&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/aws/aws-lambda-go/events&quot;&#10;&#9;ginEngine &quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;strings&quot;&#10;)&#10;&#10;type Server struct {&#10;&#9;EventHandler *http.EventHandler&#10;}&#10;&#10;func NewServer(eventService port.EventInboundPort) *Server {&#10;&#9;return &amp;Server{&#10;&#9;&#9;EventHandler: http.NewEventHandler(eventService),&#10;&#9;}&#10;}&#10;&#10;// Handler for Lambda - processes API Gateway events directly&#10;func (s *Server) Handler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {&#10;&#9;log := logger.New()&#10;&#9;log.Info(&quot;Processing Lambda request&quot;)&#10;&#10;&#9;headers := map[string]string{&#10;&#9;&#9;&quot;Content-Type&quot;:                 &quot;application/json&quot;,&#10;&#9;&#9;&quot;Access-Control-Allow-Origin&quot;:  &quot;*&quot;,&#10;&#9;&#9;&quot;Access-Control-Allow-Headers&quot;: &quot;Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token&quot;,&#10;&#9;&#9;&quot;Access-Control-Allow-Methods&quot;: &quot;POST,OPTIONS&quot;,&#10;&#9;}&#10;&#10;&#9;if req.HTTPMethod == &quot;OPTIONS&quot; {&#10;&#9;&#9;return events.APIGatewayProxyResponse{&#10;&#9;&#9;&#9;StatusCode: 200,&#10;&#9;&#9;&#9;Headers:    headers,&#10;&#9;&#9;&#9;Body:       &quot;&quot;,&#10;&#9;&#9;}, nil&#10;&#9;}&#10;&#10;&#9;if req.HTTPMethod != &quot;POST&quot; {&#10;&#9;&#9;log.Warnf(&quot;Method not allowed: %s&quot;, req.HTTPMethod)&#10;&#9;&#9;return events.APIGatewayProxyResponse{&#10;&#9;&#9;&#9;StatusCode: 405,&#10;&#9;&#9;&#9;Headers:    headers,&#10;&#9;&#9;&#9;Body:       `{&quot;error&quot;: &quot;Method not allowed&quot;}`,&#10;&#9;&#9;}, nil&#10;&#9;}&#10;&#10;&#9;if !strings.HasSuffix(req.Path, &quot;/eventos_operacao&quot;) {&#10;&#9;&#9;log.Warnf(&quot;Path not found: %s&quot;, req.Path)&#10;&#9;&#9;return events.APIGatewayProxyResponse{&#10;&#9;&#9;&#9;StatusCode: 404,&#10;&#9;&#9;&#9;Headers:    headers,&#10;&#9;&#9;&#9;Body:       `{&quot;error&quot;: &quot;Path not found&quot;}`,&#10;&#9;&#9;}, nil&#10;&#9;}&#10;&#10;&#9;// Parse the eventos_operacao payload&#10;&#9;var payload http.EventosOperacaoPayload&#10;&#9;if err := json.Unmarshal([]byte(req.Body), &amp;payload); err != nil {&#10;&#9;&#9;log.Warnf(&quot;Invalid JSON body: %v&quot;, err)&#10;&#9;&#9;return events.APIGatewayProxyResponse{&#10;&#9;&#9;&#9;StatusCode: 400,&#10;&#9;&#9;&#9;Headers:    headers,&#10;&#9;&#9;&#9;Body:       fmt.Sprintf(`{&quot;error&quot;: &quot;Invalid JSON: %s&quot;}`, err.Error()),&#10;&#9;&#9;}, nil&#10;&#9;}&#10;&#10;&#9;// Map payload to domain model&#10;&#9;eventosOperacao := &amp;model.EventosOperacao{&#10;&#9;&#9;IdPessoaFisica:       payload.IdPessoaFisica,&#10;&#9;&#9;IdPessoaJuridica:     payload.IdPessoaJuridica,&#10;&#9;&#9;NumeroContrato:       payload.NumeroContrato,&#10;&#9;&#9;IsMultiplosContratos: payload.IsMultiplosContratos,&#10;&#9;&#9;IdTipoContrato:       payload.IdTipoContrato,&#10;&#9;&#9;Metadata:             payload.Metadata,&#10;&#9;}&#10;&#10;&#9;// Validate using domain logic&#10;&#9;if !eventosOperacao.IsValid() {&#10;&#9;&#9;log.Warn(&quot;Missing required fields: at least one of idPessoaFisica or idPessoaJuridica must be provided&quot;)&#10;&#9;&#9;return events.APIGatewayProxyResponse{&#10;&#9;&#9;&#9;StatusCode: 400,&#10;&#9;&#9;&#9;Headers:    headers,&#10;&#9;&#9;&#9;Body:       `{&quot;error&quot;: &quot;Missing required fields: at least one of idPessoaFisica or idPessoaJuridica must be provided&quot;}`,&#10;&#9;&#9;}, nil&#10;&#9;}&#10;&#10;&#9;log.Infof(&quot;Processing eventos_operacao for metadata.id: %s&quot;, eventosOperacao.Metadata.Id)&#10;&#9;if err := s.EventHandler.EventService.ProcessEventosOperacao(eventosOperacao); err != nil {&#10;&#9;&#9;log.Errorf(&quot;Failed to process event: %v&quot;, err)&#10;&#9;&#9;return events.APIGatewayProxyResponse{&#10;&#9;&#9;&#9;StatusCode: 500,&#10;&#9;&#9;&#9;Headers:    headers,&#10;&#9;&#9;&#9;Body:       fmt.Sprintf(`{&quot;error&quot;: &quot;%s&quot;}`, err.Error()),&#10;&#9;&#9;}, nil&#10;&#9;}&#10;&#10;&#9;log.Info(&quot;Event processed successfully&quot;)&#10;&#9;return events.APIGatewayProxyResponse{&#10;&#9;&#9;StatusCode: 200,&#10;&#9;&#9;Headers:    headers,&#10;&#9;&#9;Body:       `{&quot;message&quot;: &quot;Event processed successfully&quot;}`,&#10;&#9;}, nil&#10;}&#10;&#10;func (s *Server) Start() {&#10;&#9;log := logger.New()&#10;&#9;log.Info(&quot;Starting GIN server for local development&quot;)&#10;&#10;&#9;r := ginEngine.Default()&#10;&#9;r.POST(&quot;/callbacks-trackingagrovarejo/v1/eventos_operacao&quot;, s.EventHandler.HandleEventosOperacao)&#10;&#10;&#9;if err := r.Run(&quot;:8080&quot;); err != nil {&#10;&#9;&#9;log.Errorf(&quot;Failed to start server: %v&quot;, err)&#10;&#9;}&#10;}&#10;&#10;// Determine event type based on payload content&#10;func (s *Server) determineEventType(payload http.EventosOperacaoPayload) string {&#10;&#9;// Business logic to determine event type based on payload content&#10;&#9;if payload.IdPessoaFisica != &quot;&quot; {&#10;&#9;&#9;return &quot;pessoa_fisica_event&quot;&#10;&#9;} else if payload.IdPessoaJuridica != &quot;&quot; {&#10;&#9;&#9;return &quot;pessoa_juridica_event&quot;&#10;&#9;} else if payload.NumeroContrato != &quot;&quot; {&#10;&#9;&#9;return &quot;contrato_event&quot;&#10;&#9;}&#10;&#9;return &quot;generic_operacao_event&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/internal/adapter/server.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/internal/adapter/server.go" />
              <option name="originalContent" value="package adapter&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;awesomeProject1/pkg/logger&quot;&#10;&#9;&quot;awesomeProject1/internal/domain/service&quot;&#10;)&#10;&#10;func StartServer(eventService service.EventService) {&#10;&#9;r := gin.Default()&#10;&#10;&#9;r.POST(&quot;/callbacks-trackingagrovarejo/v1/eventos_operacao&quot;, func(c *gin.Context) {&#10;&#9;&#9;var payload map[string]interface{}&#10;&#9;&#9;if err := c.ShouldBindJSON(&amp;payload); err != nil {&#10;&#9;&#9;&#9;logger.Warnf(&quot;Invalid request body: %v&quot;, err)&#10;&#9;&#9;&#9;c.JSON(400, gin.H{&quot;error&quot;: err.Error()})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;eventType, ok := payload[&quot;event_type&quot;].(string)&#10;&#9;&#9;if !ok || (eventType != &quot;type1&quot; &amp;&amp; eventType != &quot;type2&quot; &amp;&amp; eventType != &quot;type3&quot;) {&#10;&#9;&#9;&#9;logger.Warn(&quot;Invalid or missing event_type&quot;)&#10;&#9;&#9;&#9;c.JSON(400, gin.H{&quot;error&quot;: &quot;Invalid or missing event_type&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;logger.Infof(&quot;Processing event of type: %s&quot;, eventType)&#10;&#9;&#9;if err := eventService.ProcessAndPublishEvent(eventType, payload); err != nil {&#10;&#9;&#9;&#9;logger.Errorf(&quot;Failed to process and publish event: %v&quot;, err)&#10;&#9;&#9;&#9;c.JSON(500, gin.H{&quot;error&quot;: err.Error()})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;logger.Info(&quot;Event processed and published successfully&quot;)&#10;&#9;&#9;c.JSON(200, gin.H{&quot;message&quot;: &quot;Event processed and published successfully&quot;})&#10;&#9;})&#10;&#10;&#9;if err := r.Run(&quot;:8080&quot;); err != nil {&#10;&#9;&#9;logger.Errorf(&quot;Failed to start server: %v&quot;, err)&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package adapter&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;awesomeProject1/pkg/logger&quot;&#10;&#9;&quot;awesomeProject1/internal/domain/ports&quot;&#10;)&#10;&#10;func StartServer(inboundPort ports.InboundPort) {&#10;&#9;r := gin.Default()&#10;&#10;&#9;r.POST(&quot;/callbacks-trackingagrovarejo/v1/eventos_operacao&quot;, func(c *gin.Context) {&#10;&#9;&#9;var payload map[string]interface{}&#10;&#9;&#9;if err := c.ShouldBindJSON(&amp;payload); err != nil {&#10;&#9;&#9;&#9;logger.Warnf(&quot;Invalid request body: %v&quot;, err)&#10;&#9;&#9;&#9;c.JSON(400, gin.H{&quot;error&quot;: err.Error()})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;eventType, ok := payload[&quot;event_type&quot;].(string)&#10;&#9;&#9;if !ok || (eventType != &quot;type1&quot; &amp;&amp; eventType != &quot;type2&quot; &amp;&amp; eventType != &quot;type3&quot;) {&#10;&#9;&#9;&#9;logger.Warn(&quot;Invalid or missing event_type&quot;)&#10;&#9;&#9;&#9;c.JSON(400, gin.H{&quot;error&quot;: &quot;Invalid or missing event_type&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;logger.Infof(&quot;Processing event of type: %s&quot;, eventType)&#10;&#9;&#9;if err := inboundPort.ProcessEvent(eventType, payload); err != nil {&#10;&#9;&#9;&#9;logger.Errorf(&quot;Failed to process event: %v&quot;, err)&#10;&#9;&#9;&#9;c.JSON(500, gin.H{&quot;error&quot;: err.Error()})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;logger.Info(&quot;Event processed successfully&quot;)&#10;&#9;&#9;c.JSON(200, gin.H{&quot;message&quot;: &quot;Event processed successfully&quot;})&#10;&#9;})&#10;&#10;&#9;if err := r.Run(&quot;:8080&quot;); err != nil {&#10;&#9;&#9;logger.Errorf(&quot;Failed to start server: %v&quot;, err)&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/internal/core/domain/model/event.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/internal/core/domain/model/event.go" />
              <option name="originalContent" value="package model&#10;&#10;type Event struct {&#10;&#9;ID          string                 `json:&quot;id&quot;`&#10;&#9;Payload     map[string]interface{} `json:&quot;payload&quot;`&#10;&#9;ProcessedAt string                 `json:&quot;processed_at&quot;`&#10;}&#10;" />
              <option name="updatedContent" value="package model&#10;&#10;import &quot;time&quot;&#10;&#10;// Event represents a processed event with metadata&#10;type Event struct {&#10;&#9;ID          string                 `json:&quot;id&quot;`&#10;&#9;Payload     map[string]interface{} `json:&quot;payload&quot;`&#10;&#9;ProcessedAt string                 `json:&quot;processed_at&quot;`&#10;}&#10;&#10;// EventosOperacao represents the domain model for eventos operacao&#10;type EventosOperacao struct {&#10;&#9;IdPessoaFisica       string    `json:&quot;idPessoaFisica&quot;`&#10;&#9;IdPessoaJuridica     string    `json:&quot;idPessoaJuridica&quot;`&#10;&#9;NumeroContrato       string    `json:&quot;numeroContrato&quot;`&#10;&#9;IsMultiplosContratos bool      `json:&quot;isMultiplosContratos&quot;`&#10;&#9;IdTipoContrato       string    `json:&quot;idTipoContrato&quot;`&#10;&#9;Metadata             Metadata  `json:&quot;metadata&quot;`&#10;&#9;EventType            string    `json:&quot;eventType&quot;`&#10;&#9;ProcessedAt          time.Time `json:&quot;processedAt&quot;`&#10;}&#10;&#10;// Metadata represents the metadata information for eventos operacao&#10;type Metadata struct {&#10;&#9;Id              string `json:&quot;id&quot;`&#10;&#9;Nome            string `json:&quot;nome&quot;`&#10;&#9;Descricao       string `json:&quot;descricao&quot;`&#10;&#9;DataCriacao     string `json:&quot;dataCriacao&quot;`&#10;&#9;DataAtualizacao string `json:&quot;dataAtualizacao&quot;`&#10;}&#10;&#10;// IsValid validates the domain model&#10;func (e *EventosOperacao) IsValid() bool {&#10;&#9;return e.IdPessoaFisica != &quot;&quot; || e.IdPessoaJuridica != &quot;&quot;&#10;}&#10;&#10;// DetermineEventType determines the event type based on payload content&#10;func (e *EventosOperacao) DetermineEventType() string {&#10;&#9;if e.IdPessoaFisica != &quot;&quot; {&#10;&#9;&#9;return &quot;pessoa_fisica_event&quot;&#10;&#9;} else if e.IdPessoaJuridica != &quot;&quot; {&#10;&#9;&#9;return &quot;pessoa_juridica_event&quot;&#10;&#9;} else if e.NumeroContrato != &quot;&quot; {&#10;&#9;&#9;return &quot;contrato_event&quot;&#10;&#9;}&#10;&#9;return &quot;generic_operacao_event&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/internal/core/domain/service/event_service.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/internal/core/domain/service/event_service.go" />
              <option name="originalContent" value="package service&#10;&#10;import (&#10;&#9;&quot;awesomeProject1/internal/core/domain/model&quot;&#10;&#9;&quot;awesomeProject1/internal/core/port&quot;&#10;&#9;&quot;awesomeProject1/pkg/logger&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;type EventService struct {&#10;&#9;Publisher port.EventOutboundPort&#10;}&#10;&#10;func NewEventService(publisher port.EventOutboundPort) *EventService {&#10;&#9;return &amp;EventService{&#10;&#9;&#9;Publisher: publisher,&#10;&#9;}&#10;}&#10;&#10;func (s *EventService) ProcessEvent(eventType string, payload map[string]interface{}) error {&#10;&#9;log := logger.New()&#10;&#9;log.Debugf(&quot;Starting to process event of type: %s&quot;, eventType)&#10;&#10;&#9;payload[&quot;event_type&quot;] = eventType&#10;&#10;&#9;event := model.Event{&#10;&#9;&#9;ID:          &quot;unique-id&quot;,&#10;&#9;&#9;Payload:     payload,&#10;&#9;&#9;ProcessedAt: time.Now().Format(time.RFC3339),&#10;&#9;}&#10;&#10;&#9;log.Infof(&quot;Event created with ID: %s and type: %s&quot;, event.ID, eventType)&#10;&#10;&#9;err := s.Publisher.PublishEvent(eventType, event.Payload)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Errorf(&quot;Failed to publish event: %v&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;log.Info(&quot;Event published successfully&quot;)&#10;&#9;return nil&#10;}&#10;" />
              <option name="updatedContent" value="package service&#10;&#10;import (&#10;&#9;&quot;awesomeProject1/internal/core/domain/model&quot;&#10;&#9;&quot;awesomeProject1/internal/core/port&quot;&#10;&#9;&quot;awesomeProject1/pkg/logger&quot;&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;type EventService struct {&#10;&#9;Publisher port.EventOutboundPort&#10;}&#10;&#10;func NewEventService(publisher port.EventOutboundPort) *EventService {&#10;&#9;return &amp;EventService{&#10;&#9;&#9;Publisher: publisher,&#10;&#9;}&#10;}&#10;&#10;func (s *EventService) ProcessEventosOperacao(eventosOperacao *model.EventosOperacao) error {&#10;&#9;log := logger.New()&#10;&#9;log.Debugf(&quot;Starting to process eventos operacao of type: %s&quot;, eventosOperacao.EventType)&#10;&#10;&#9;// Validate the domain model&#10;&#9;if !eventosOperacao.IsValid() {&#10;&#9;&#9;log.Error(&quot;Invalid eventos operacao: missing required person identifiers&quot;)&#10;&#9;&#9;return fmt.Errorf(&quot;invalid eventos operacao: at least one of idPessoaFisica or idPessoaJuridica must be provided&quot;)&#10;&#9;}&#10;&#10;&#9;// Set processing timestamp&#10;&#9;eventosOperacao.ProcessedAt = time.Now()&#10;&#10;&#9;// Determine event type based on domain logic&#10;&#9;eventosOperacao.EventType = eventosOperacao.DetermineEventType()&#10;&#10;&#9;log.Infof(&quot;Processing eventos operacao of type: %s for metadata.id: %s&quot;,&#10;&#9;&#9;eventosOperacao.EventType, eventosOperacao.Metadata.Id)&#10;&#10;&#9;// Convert domain model to map for publishing (SNS still needs this format)&#10;&#9;payloadMap, err := s.convertToMap(eventosOperacao)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Errorf(&quot;Failed to convert domain model to map: %v&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// Publish the event&#10;&#9;err = s.Publisher.PublishEvent(eventosOperacao.EventType, payloadMap)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Errorf(&quot;Failed to publish event: %v&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;log.Info(&quot;Eventos operacao processed and published successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;// convertToMap converts the domain model to a map for publishing&#10;func (s *EventService) convertToMap(eventosOperacao *model.EventosOperacao) (map[string]interface{}, error) {&#10;&#9;// Convert struct to JSON then to map to preserve all field mappings&#10;&#9;jsonData, err := json.Marshal(eventosOperacao)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;var payloadMap map[string]interface{}&#10;&#9;err = json.Unmarshal(jsonData, &amp;payloadMap)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return payloadMap, nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/internal/core/port/event_interface.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/internal/core/port/event_interface.go" />
              <option name="originalContent" value="package port&#10;&#10;type EventInboundPort interface {&#10;&#9;ProcessEvent(eventType string, payload map[string]interface{}) error&#10;}&#10;&#10;type EventOutboundPort interface {&#10;&#9;PublishEvent(eventType string, payload map[string]interface{}) error&#10;}&#10;" />
              <option name="updatedContent" value="package port&#10;&#10;import &quot;awesomeProject1/internal/core/domain/model&quot;&#10;&#10;// EventInboundPort defines the interface for processing events (primary port)&#10;type EventInboundPort interface {&#10;&#9;ProcessEventosOperacao(eventosOperacao *model.EventosOperacao) error&#10;}&#10;&#10;// EventOutboundPort defines the interface for publishing events (secondary port)&#10;type EventOutboundPort interface {&#10;&#9;PublishEvent(eventType string, payload map[string]interface{}) error&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/internal/domain/ports/inbound.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/internal/domain/ports/inbound.go" />
              <option name="updatedContent" value="package ports&#10;&#10;// InboundPort defines the interface for handling API requests.&#10;type InboundPort interface {&#10;&#9;ProcessEvent(eventType string, payload map[string]interface{}) error&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/internal/domain/ports/outbound.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/internal/domain/ports/outbound.go" />
              <option name="originalContent" value="&#10;// OutboundPort defines the interface for publishing events to external systems.&#10;type OutboundPort interface {&#10;&#9;PublishEvent(eventType string, payload map[string]interface{}) error&#10;}" />
              <option name="updatedContent" value="package ports&#10;&#10;// OutboundPort defines the interface for publishing events to external systems.&#10;type OutboundPort interface {&#10;&#9;PublishEvent(eventType string, payload map[string]interface{}) error&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/main.go" />
              <option name="originalContent" value="package main&#10;&#10;import (&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;github.com/aws/aws-lambda-go/events&quot;&#10;&#9;&quot;github.com/aws/aws-lambda-go/lambda&quot;&#10;)&#10;&#10;func handler(request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {&#10;&#9;if request.HTTPMethod == &quot;POST&quot; &amp;&amp; request.Path == &quot;/callbacks-trackingagrovarejo/v1/eventos_operacao&quot; {&#10;&#9;&#9;var body map[string]interface{}&#10;&#9;&#9;err := json.Unmarshal([]byte(request.Body), &amp;body)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return events.APIGatewayProxyResponse{&#10;&#9;&#9;&#9;&#9;StatusCode: 400,&#10;&#9;&#9;&#9;&#9;Headers:    map[string]string{&quot;Content-Type&quot;: &quot;application/json&quot;},&#10;&#9;&#9;&#9;&#9;Body:       `{&quot;error&quot;: &quot;` + err.Error() + `&quot;}`,&#10;&#9;&#9;&#9;}, nil&#10;&#9;&#9;}&#10;&#9;&#9;responseBody, _ := json.Marshal(map[string]interface{}{&#10;&#9;&#9;&#9;&quot;message&quot;:  &quot;Event received successfully&quot;,&#10;&#9;&#9;&#9;&quot;received&quot;: body,&#10;&#9;&#9;})&#10;&#9;&#9;return events.APIGatewayProxyResponse{&#10;&#9;&#9;&#9;StatusCode: 200,&#10;&#9;&#9;&#9;Headers:    map[string]string{&quot;Content-Type&quot;: &quot;application/json&quot;},&#10;&#9;&#9;&#9;Body:       string(responseBody),&#10;&#9;&#9;}, nil&#10;&#9;}&#10;&#9;return events.APIGatewayProxyResponse{&#10;&#9;&#9;StatusCode: 404,&#10;&#9;&#9;Headers:    map[string]string{&quot;Content-Type&quot;: &quot;application/json&quot;},&#10;&#9;&#9;Body:       `{&quot;error&quot;: &quot;Not Found&quot;}`,&#10;&#9;}, nil&#10;}&#10;&#10;func main() {&#10;&#9;lambda.Start(handler)&#10;}&#10;" />
              <option name="updatedContent" value="package main&#10;&#10;import (&#10;&#9;&quot;awesomeProject1/app/application&quot;&#10;&#9;&quot;awesomeProject1/app/infrastructure&quot;&#10;&#9;&quot;context&quot;&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;github.com/aws/aws-lambda-go/events&quot;&#10;&#9;&quot;github.com/aws/aws-lambda-go/lambda&quot;&#10;&#9;&quot;github.com/aws/aws-sdk-go-v2/aws&quot;&#10;&#9;&quot;github.com/aws/aws-sdk-go-v2/config&quot;&#10;&#9;&quot;github.com/aws/aws-sdk-go-v2/service/sns&quot;&#10;&#9;&quot;log&quot;&#10;)&#10;&#10;var eventService *application.EventService&#10;&#10;func init() {&#10;&#9;cfg, err := config.LoadDefaultConfig(context.TODO(), config.WithRegion(&quot;us-east-1&quot;))&#10;&#9;if err != nil {&#10;&#9;&#9;log.Fatalf(&quot;failed to load configuration, %v&quot;, err)&#10;&#9;}&#10;&#10;&#9;snsClient := sns.NewFromConfig(cfg)&#10;&#9;snsPublisher := infrastructure.SNSPublisher{&#10;&#9;&#9;Client:   snsClient,&#10;&#9;&#9;TopicArn: &quot;arn:aws:sns:us-east-1:000000000000:my-topic&quot;, // Replace with your SNS topic ARN&#10;&#9;}&#10;&#9;eventService = &amp;application.EventService{&#10;&#9;&#9;SNSPublisher: snsPublisher,&#10;&#9;}&#10;}&#10;&#10;func handler(request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {&#10;&#9;if request.HTTPMethod == &quot;POST&quot; &amp;&amp; request.Path == &quot;/callbacks-trackingagrovarejo/v1/eventos_operacao&quot; {&#10;&#9;&#9;var payload map[string]interface{}&#10;&#9;&#9;err := json.Unmarshal([]byte(request.Body), &amp;payload)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return events.APIGatewayProxyResponse{&#10;&#9;&#9;&#9;&#9;StatusCode: 400,&#10;&#9;&#9;&#9;&#9;Headers:    map[string]string{&quot;Content-Type&quot;: &quot;application/json&quot;},&#10;&#9;&#9;&#9;&#9;Body:       `{&quot;error&quot;: &quot;` + err.Error() + `&quot;}`,&#10;&#9;&#9;&#9;}, nil&#10;&#9;&#9;}&#10;&#10;&#9;&#9;err = eventService.ProcessAndPublishEvent(payload)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return events.APIGatewayProxyResponse{&#10;&#9;&#9;&#9;&#9;StatusCode: 500,&#10;&#9;&#9;&#9;&#9;Headers:    map[string]string{&quot;Content-Type&quot;: &quot;application/json&quot;},&#10;&#9;&#9;&#9;&#9;Body:       `{&quot;error&quot;: &quot;` + err.Error() + `&quot;}`,&#10;&#9;&#9;&#9;}, nil&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return events.APIGatewayProxyResponse{&#10;&#9;&#9;&#9;StatusCode: 200,&#10;&#9;&#9;&#9;Headers:    map[string]string{&quot;Content-Type&quot;: &quot;application/json&quot;},&#10;&#9;&#9;&#9;Body:       `{&quot;message&quot;: &quot;Event processed and published successfully&quot;}`,&#10;&#9;&#9;}, nil&#10;&#9;}&#10;&#9;return events.APIGatewayProxyResponse{&#10;&#9;&#9;StatusCode: 404,&#10;&#9;&#9;Headers:    map[string]string{&quot;Content-Type&quot;: &quot;application/json&quot;},&#10;&#9;&#9;Body:       `{&quot;error&quot;: &quot;Not Found&quot;}`,&#10;&#9;}, nil&#10;}&#10;&#10;func main() {&#10;&#9;lambda.Start(handler)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/pkg/cfg/awscfg.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/pkg/cfg/awscfg.go" />
              <option name="originalContent" value="package cfg&#10;" />
              <option name="updatedContent" value="package cfg&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;github.com/aws/aws-sdk-go-v2/aws&quot;&#10;&#9;&quot;github.com/aws/aws-sdk-go-v2/config&quot;&#10;&#9;&quot;github.com/aws/aws-sdk-go-v2/service/sns&quot;&#10;)&#10;&#10;// AWSService holds AWS service clients&#10;type AWSService struct {&#10;&#9;SNSClient *sns.Client&#10;&#9;Config    *Config&#10;}&#10;&#10;// NewAWSService creates a new AWS service with proper configuration&#10;func NewAWSService(cfg *Config) (*AWSService, error) {&#10;&#9;// Load AWS configuration&#10;&#9;awsCfg, err := config.LoadDefaultConfig(context.TODO(), config.WithRegion(cfg.AWS.Region))&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Create SNS client&#10;&#9;var snsClient *sns.Client&#10;&#9;if cfg.IsLocalStack() {&#10;&#9;&#9;// Configure for LocalStack&#10;&#9;&#9;snsClient = sns.NewFromConfig(awsCfg, func(o *sns.Options) {&#10;&#9;&#9;&#9;o.BaseEndpoint = aws.String(cfg.AWS.LocalStack.Endpoint)&#10;&#9;&#9;})&#10;&#9;} else {&#10;&#9;&#9;// Configure for real AWS&#10;&#9;&#9;snsClient = sns.NewFromConfig(awsCfg)&#10;&#9;}&#10;&#10;&#9;return &amp;AWSService{&#10;&#9;&#9;SNSClient: snsClient,&#10;&#9;&#9;Config:    cfg,&#10;&#9;}, nil&#10;}&#10;&#10;// GetSNSClient returns the configured SNS client&#10;func (a *AWSService) GetSNSClient() *sns.Client {&#10;&#9;return a.SNSClient&#10;}&#10;&#10;// GetSNSTopicArn returns the appropriate SNS topic ARN&#10;func (a *AWSService) GetSNSTopicArn() string {&#10;&#9;return a.Config.GetSNSTopicArn()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/pkg/cfg/cfg.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/pkg/cfg/cfg.go" />
              <option name="originalContent" value="package cfg&#10;" />
              <option name="updatedContent" value="package cfg&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/spf13/viper&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;strings&quot;&#10;)&#10;&#10;// Config holds all configuration for the application&#10;type Config struct {&#10;&#9;App     AppConfig     `mapstructure:&quot;app&quot;`&#10;&#9;AWS     AWSConfig     `mapstructure:&quot;aws&quot;`&#10;&#9;SNS     SNSConfig     `mapstructure:&quot;sns&quot;`&#10;&#9;Server  ServerConfig  `mapstructure:&quot;server&quot;`&#10;&#9;Logging LoggingConfig `mapstructure:&quot;logging&quot;`&#10;}&#10;&#10;type AppConfig struct {&#10;&#9;Name        string `mapstructure:&quot;name&quot;`&#10;&#9;Environment string `mapstructure:&quot;environment&quot;`&#10;}&#10;&#10;type AWSConfig struct {&#10;&#9;Region     string             `mapstructure:&quot;region&quot;`&#10;&#9;LocalStack LocalStackConfig   `mapstructure:&quot;localstack&quot;`&#10;}&#10;&#10;type LocalStackConfig struct {&#10;&#9;Enabled  bool   `mapstructure:&quot;enabled&quot;`&#10;&#9;Endpoint string `mapstructure:&quot;endpoint&quot;`&#10;}&#10;&#10;type SNSConfig struct {&#10;&#9;TopicArn     string `mapstructure:&quot;topic_arn&quot;`&#10;&#9;TopicArnProd string `mapstructure:&quot;topic_arn_prod&quot;`&#10;}&#10;&#10;type ServerConfig struct {&#10;&#9;Port int `mapstructure:&quot;port&quot;`&#10;}&#10;&#10;type LoggingConfig struct {&#10;&#9;Level string `mapstructure:&quot;level&quot;`&#10;}&#10;&#10;// Load loads configuration from env.yaml and environment variables&#10;func Load() (*Config, error) {&#10;&#9;viper.SetConfigName(&quot;env&quot;)&#10;&#9;viper.SetConfigType(&quot;yaml&quot;)&#10;&#9;viper.AddConfigPath(&quot;.&quot;)&#10;&#9;viper.AddConfigPath(&quot;./&quot;)&#10;&#9;&#10;&#9;// Enable environment variable support&#10;&#9;viper.AutomaticEnv()&#10;&#9;viper.SetEnvKeyReplacer(strings.NewReplacer(&quot;.&quot;, &quot;_&quot;))&#10;&#9;&#10;&#9;// Read config file&#10;&#9;if err := viper.ReadInConfig(); err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;failed to read config file: %w&quot;, err)&#10;&#9;}&#10;&#9;&#10;&#9;var config Config&#10;&#9;if err := viper.Unmarshal(&amp;config); err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;failed to unmarshal config: %w&quot;, err)&#10;&#9;}&#10;&#9;&#10;&#9;// Override with environment variables if present&#10;&#9;config.overrideWithEnvVars()&#10;&#9;&#10;&#9;return &amp;config, nil&#10;}&#10;&#10;// overrideWithEnvVars overrides config values with environment variables&#10;func (c *Config) overrideWithEnvVars() {&#10;&#9;// Override app environment&#10;&#9;if env := os.Getenv(&quot;APP_ENVIRONMENT&quot;); env != &quot;&quot; {&#10;&#9;&#9;c.App.Environment = env&#10;&#9;}&#10;&#9;&#10;&#9;// Override AWS region&#10;&#9;if region := os.Getenv(&quot;AWS_REGION&quot;); region != &quot;&quot; {&#10;&#9;&#9;c.AWS.Region = region&#10;&#9;}&#10;&#9;&#10;&#9;// Override LocalStack settings&#10;&#9;if enabled := os.Getenv(&quot;AWS_LOCALSTACK_ENABLED&quot;); enabled != &quot;&quot; {&#10;&#9;&#9;c.AWS.LocalStack.Enabled = enabled == &quot;true&quot;&#10;&#9;}&#10;&#9;&#10;&#9;if endpoint := os.Getenv(&quot;AWS_LOCALSTACK_ENDPOINT&quot;); endpoint != &quot;&quot; {&#10;&#9;&#9;c.AWS.LocalStack.Endpoint = endpoint&#10;&#9;}&#10;&#9;&#10;&#9;// Override SNS topic ARN&#10;&#9;if topicArn := os.Getenv(&quot;SNS_TOPIC_ARN&quot;); topicArn != &quot;&quot; {&#10;&#9;&#9;c.SNS.TopicArn = topicArn&#10;&#9;}&#10;&#9;&#10;&#9;// Override server port&#10;&#9;if port := os.Getenv(&quot;SERVER_PORT&quot;); port != &quot;&quot; {&#10;&#9;&#9;if p := viper.GetInt(&quot;SERVER_PORT&quot;); p &gt; 0 {&#10;&#9;&#9;&#9;c.Server.Port = p&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;&#10;&#9;// Override logging level&#10;&#9;if level := os.Getenv(&quot;LOGGING_LEVEL&quot;); level != &quot;&quot; {&#10;&#9;&#9;c.Logging.Level = level&#10;&#9;}&#10;}&#10;&#10;// IsLocalStack returns true if LocalStack should be used&#10;func (c *Config) IsLocalStack() bool {&#10;&#9;// Check if running in Lambda (production)&#10;&#9;if os.Getenv(&quot;AWS_LAMBDA_RUNTIME_API&quot;) != &quot;&quot; {&#10;&#9;&#9;return false&#10;&#9;}&#10;&#9;&#10;&#9;// Check explicit environment variable&#10;&#9;if useLocalStack := os.Getenv(&quot;USE_LOCALSTACK&quot;); useLocalStack != &quot;&quot; {&#10;&#9;&#9;return useLocalStack == &quot;true&quot;&#10;&#9;}&#10;&#9;&#10;&#9;// Use config setting&#10;&#9;return c.AWS.LocalStack.Enabled&#10;}&#10;&#10;// GetSNSTopicArn returns the appropriate SNS topic ARN based on environment&#10;func (c *Config) GetSNSTopicArn() string {&#10;&#9;if c.IsLocalStack() || c.App.Environment == &quot;local&quot; {&#10;&#9;&#9;return c.SNS.TopicArn&#10;&#9;}&#10;&#9;return c.SNS.TopicArnProd&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/cmd/lambda/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/cmd/lambda/main.go" />
              <option name="originalContent" value="package main&#10;&#10;import (&#10;&#9;adapterin &quot;awesomeProject1/internal/adapter/in&quot;&#10;&#9;adapterout &quot;awesomeProject1/internal/adapter/out&quot;&#10;&#9;&quot;awesomeProject1/internal/core&quot;&#10;&#9;&quot;github.com/aws/aws-sdk-go/aws/session&quot;&#10;&#9;&quot;os&quot;&#10;)&#10;&#10;func main() {&#10;&#9;topicArn := os.Getenv(&quot;SNS_TOPIC_ARN&quot;)&#10;&#9;sess := session.Must(session.NewSession())&#10;&#9;snsPublisher := adapterout.NewSNSPublisher(sess, topicArn)&#10;&#9;service := core.NewService(snsPublisher)&#10;&#9;adapterin.StartLambda(service)&#10;}&#10;" />
              <option name="updatedContent" value="package main&#10;&#10;import (&#10;&#9;adapterin &quot;awesomeProject1/internal/adapter/in&quot;&#10;&#9;adapterout &quot;awesomeProject1/internal/adapter/out&quot;&#10;&#9;&quot;awesomeProject1/internal/core&quot;&#10;&#9;&quot;github.com/aws/aws-sdk-go-v2/config&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;context&quot;&#10;)&#10;&#10;func main() {&#10;&#9;topicArn := os.Getenv(&quot;SNS_TOPIC_ARN&quot;)&#10;&#9;cfg, err := config.LoadDefaultConfig(context.Background())&#10;&#9;if err != nil {&#10;&#9;&#9;panic(err)&#10;&#9;}&#10;&#9;snsPublisher := adapterout.NewSNSPublisher(cfg, topicArn)&#10;&#9;service := core.NewService(snsPublisher)&#10;&#9;adapterin.StartLambda(service)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docker-compose.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docker-compose.yml" />
              <option name="updatedContent" value="version: '3.8'&#10;services:&#10;  localstack:&#10;    image: localstack/localstack:3.4&#10;    environment:&#10;      - SERVICES=lambda,apigateway&#10;      - DEBUG=1&#10;      - LAMBDA_EXECUTOR=docker&#10;      - DOCKER_HOST=unix:///var/run/docker.sock&#10;      - AWS_DEFAULT_REGION=us-east-1&#10;      - AWS_ACCESS_KEY_ID=test&#10;      - AWS_SECRET_ACCESS_KEY=test&#10;    ports:&#10;      - &quot;4566:4566&quot;&#10;      - &quot;4571:4571&quot;&#10;    volumes:&#10;      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;&#10;      - ./localstack-init:/etc/localstack/init/ready.d&#10;&#10;  lambda:&#10;    build: .&#10;    environment:&#10;      - AWS_REGION=us-east-1&#10;    depends_on:&#10;      - localstack&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/adapter/in/lambda.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/adapter/in/lambda.go" />
              <option name="updatedContent" value="package lambda&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;github.com/aws/aws-lambda-go/events&quot;&#10;&#9;&quot;github.com/aws/aws-lambda-go/lambda&quot;&#10;&#9;&quot;awesomeProject1/internal/core&quot;&#10;)&#10;&#10;type Handler struct {&#10;&#9;Processor core.Processor&#10;}&#10;&#10;func (h *Handler) HandleRequest(ctx context.Context, event events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {&#10;&#9;err := h.Processor.Process(ctx, []byte(event.Body))&#10;&#9;if err != nil {&#10;&#9;&#9;return events.APIGatewayProxyResponse{StatusCode: 500, Body: err.Error()}, nil&#10;&#9;}&#10;&#9;return events.APIGatewayProxyResponse{StatusCode: 200, Body: `{&quot;message&quot;:&quot;ok&quot;}`}, nil&#10;}&#10;&#10;func StartLambda(processor core.Processor) {&#10;&#9;h := &amp;Handler{Processor: processor}&#10;&#9;lambda.Start(h.HandleRequest)&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/adapter/out/sns.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/adapter/out/sns.go" />
              <option name="originalContent" value="package out&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;github.com/aws/aws-sdk-go/aws&quot;&#10;&#9;&quot;github.com/aws/aws-sdk-go/aws/session&quot;&#10;&#9;&quot;github.com/aws/aws-sdk-go/service/sns&quot;&#10;)&#10;&#10;type SNSPublisher struct {&#10;&#9;snsClient *sns.SNS&#10;&#9;topicArn  string&#10;}&#10;&#10;func NewSNSPublisher(sess *session.Session, topicArn string) *SNSPublisher {&#10;&#9;return &amp;SNSPublisher{&#10;&#9;&#9;snsClient: sns.New(sess),&#10;&#9;&#9;topicArn:  topicArn,&#10;&#9;}&#10;}&#10;&#10;func (p *SNSPublisher) Publish(ctx context.Context, message string) error {&#10;&#9;_, err := p.snsClient.PublishWithContext(ctx, &amp;sns.PublishInput{&#10;&#9;&#9;Message:  aws.String(message),&#10;&#9;&#9;TopicArn: aws.String(p.topicArn),&#10;&#9;})&#10;&#9;return err&#10;}&#10;" />
              <option name="updatedContent" value="package out&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;github.com/aws/aws-sdk-go-v2/aws&quot;&#10;&#9;&quot;github.com/aws/aws-sdk-go-v2/config&quot;&#10;&#9;&quot;github.com/aws/aws-sdk-go-v2/service/sns&quot;&#10;)&#10;&#10;type SNSPublisher struct {&#10;&#9;snsClient *sns.Client&#10;&#9;topicArn  string&#10;}&#10;&#10;func NewSNSPublisher(cfg aws.Config, topicArn string) *SNSPublisher {&#10;&#9;return &amp;SNSPublisher{&#10;&#9;&#9;snsClient: sns.NewFromConfig(cfg),&#10;&#9;&#9;topicArn:  topicArn,&#10;&#9;}&#10;}&#10;&#10;func (p *SNSPublisher) Publish(ctx context.Context, message string) error {&#10;&#9;_, err := p.snsClient.Publish(ctx, &amp;sns.PublishInput{&#10;&#9;&#9;Message:  aws.String(message),&#10;&#9;&#9;TopicArn: aws.String(p.topicArn),&#10;&#9;})&#10;&#9;return err&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/core/service.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/core/service.go" />
              <option name="updatedContent" value="package service&#10;&#10;import &quot;context&quot;&#10;&#10;type Processor interface {&#10;&#9;Process(ctx context.Context, payload []byte) error&#10;}&#10;&#10;// Service implements the core business logic&#10;func NewService(snsPublisher SNSPublisher) Processor {&#10;&#9;return &amp;service{snsPublisher: snsPublisher}&#10;}&#10;&#10;type SNSPublisher interface {&#10;&#9;Publish(ctx context.Context, message string) error&#10;}&#10;&#10;type service struct {&#10;&#9;snsPublisher SNSPublisher&#10;}&#10;&#10;func (s *service) Process(ctx context.Context, payload []byte) error {&#10;&#9;// Example: just forward the payload as a string to SNS&#10;&#9;return s.snsPublisher.Publish(ctx, string(payload))&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/port/in/api.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/port/in/api.go" />
              <option name="updatedContent" value="package in&#10;&#10;import &quot;context&quot;&#10;&#10;type APIHandler interface {&#10;&#9;Handle(ctx context.Context, payload []byte) error&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/port/out/sns.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/port/out/sns.go" />
              <option name="updatedContent" value="package out&#10;&#10;import &quot;context&quot;&#10;&#10;type SNSPublisher interface {&#10;&#9;Publish(ctx context.Context, message string) error&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/localstack-init/01-setup.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/localstack-init/01-setup.sh" />
              <option name="updatedContent" value="#!/bin/bash&#10;set -e&#10;&#10;# Create Lambda function in LocalStack&#10;awslocal lambda create-function \&#10;  --function-name my-lambda-function \&#10;  --runtime go1.x \&#10;  --handler main \&#10;  --role arn:aws:iam::000000000000:role/lambda-role \&#10;  --zip-file fileb:///var/task/main&#10;&#10;# Create API Gateway and integrate with Lambda&#10;API_ID=$(awslocal apigateway create-rest-api --name &quot;MyAPI&quot; | jq -r .id)&#10;PARENT_RESOURCE_ID=$(awslocal apigateway get-resources --rest-api-id $API_ID | jq -r .items[0].id)&#10;RESOURCE_ID=$(awslocal apigateway create-resource --rest-api-id $API_ID --parent-id $PARENT_RESOURCE_ID --path-part callbacks-trackingagrovarejo | jq -r .id)&#10;RESOURCE_ID2=$(awslocal apigateway create-resource --rest-api-id $API_ID --parent-id $RESOURCE_ID --path-part v1 | jq -r .id)&#10;RESOURCE_ID3=$(awslocal apigateway create-resource --rest-api-id $API_ID --parent-id $RESOURCE_ID2 --path-part eventos_operacao | jq -r .id)&#10;&#10;awslocal apigateway put-method --rest-api-id $API_ID --resource-id $RESOURCE_ID3 --http-method POST --authorization-type &quot;NONE&quot;&#10;awslocal apigateway put-integration --rest-api-id $API_ID --resource-id $RESOURCE_ID3 --http-method POST --type AWS_PROXY --integration-http-method POST --uri arn:aws:apigateway:us-east-1:lambda:path/2015-03-31/functions/arn:aws:lambda:us-east-1:000000000000:function:my-lambda-function/invocations&#10;awslocal lambda add-permission --function-name my-lambda-function --statement-id apigateway-test-2 --action lambda:InvokeFunction --principal apigateway.amazonaws.com --source-arn arn:aws:execute-api:us-east-1:000000000000:$API_ID/*/POST/callbacks-trackingagrovarejo/v1/eventos_operacao&#10;awslocal apigateway create-deployment --rest-api-id $API_ID --stage-name dev&#10;&#10;echo &quot;API endpoint: http://localhost:4566/restapis/$API_ID/dev/_user_request_/callbacks-trackingagrovarejo/v1/eventos_operacao&quot;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test-payloads.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test-payloads.json" />
              <option name="originalContent" value="{&#10;  &quot;idPessoaFisica&quot;: &quot;&quot;,&#10;  &quot;idPessoaJuridica&quot;: &quot;&quot;,&#10;  &quot;numeroContrato&quot;: &quot;&quot;,&#10;  &quot;isMultiplosContratos&quot;: false,&#10;  &quot;idTipoContrato&quot;: &quot;&quot;,&#10;  &quot;metadata&quot;: {&#10;    &quot;id&quot;: &quot;1234567890&quot;,&#10;    &quot;nome&quot;: &quot;Teste de Payloads&quot;,&#10;    &quot;descricao&quot;: &quot;Payloads para testes automatizados&quot;,&#10;    &quot;dataCriacao&quot;: &quot;2023-10-01T12:00:00Z&quot;,&#10;    &quot;dataAtualizacao&quot;: &quot;2023-10-01T12:00:00Z&quot;&#10;  }&#10;}" />
              <option name="updatedContent" value="{&#10;  &quot;idPessoaFisica&quot;: &quot;&quot;,&#10;  &quot;idPessoaJuridica&quot;: &quot;&quot;,&#10;  &quot;numeroContrato&quot;: &quot;&quot;,&#10;  &quot;isMultiplosContratos&quot;: false,&#10;  &quot;idTipoContrato&quot;: &quot;&quot;,&#10;  &quot;metadata&quot;: {&#10;    &quot;id&quot;: &quot;1234567890&quot;,&#10;    &quot;nome&quot;: &quot;Teste de Payloads&quot;,&#10;    &quot;descricao&quot;: &quot;Payloads para testes automatizados&quot;,&#10;    &quot;dataCriacao&quot;: &quot;2023-10-01T12:00:00Z&quot;,&#10;    &quot;dataAtualizacao&quot;: &quot;2023-10-01T12:00:00Z&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>